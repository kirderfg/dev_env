#!/bin/bash
set -e

# Configuration
RESOURCE_GROUP="rg-dev-env"
LOCATION="swedencentral"
VM_NAME="vm-dev"
SSH_USER="azureuser"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INFRA_DIR="${SCRIPT_DIR}/../infra"
ENV_FILE="${SCRIPT_DIR}/../.env"
OP_TOKEN_FILE="${HOME}/.config/dev_env/op_token"

echo "=== Azure Dev VM Deployment ==="

# Check if Azure CLI is installed
if ! command -v az &> /dev/null; then
    echo "Error: Azure CLI is not installed. Install it from https://docs.microsoft.com/en-us/cli/azure/install-azure-cli"
    exit 1
fi

# Check if logged in to Azure
if ! az account show &> /dev/null; then
    echo "Error: Not logged in to Azure. Run 'az login' first."
    exit 1
fi

# Check if VM already exists
echo "Checking for existing VM..."
VM_EXISTS=$(az vm show --resource-group "${RESOURCE_GROUP}" --name "${VM_NAME}" --query "id" -o tsv 2>/dev/null || true)

if [ -n "$VM_EXISTS" ]; then
    echo ""
    echo "WARNING: VM '${VM_NAME}' already exists in resource group '${RESOURCE_GROUP}'."
    echo "Cloud-init configuration cannot be changed on an existing VM."
    echo ""
    read -p "Delete resource group and start fresh? (y/n): " -n 1 -r REPLY </dev/tty
    echo ""

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo "Deleting resource group ${RESOURCE_GROUP}..."
        az group delete --name "${RESOURCE_GROUP}" --yes --no-wait

        echo "Waiting for deletion to complete..."
        while az group show --name "${RESOURCE_GROUP}" &>/dev/null; do
            echo -n "."
            sleep 5
        done
        echo ""
        echo "Resource group deleted."
    else
        echo "Aborting. To update NSG rules only, use Azure Portal or az CLI directly."
        exit 0
    fi
fi

# Generate throwaway SSH key (required by Azure, but we use Tailscale for access)
echo "Generating temporary SSH key for Azure..."
TEMP_KEY=$(mktemp -u)  # -u creates name only, doesn't create file
ssh-keygen -t ed25519 -f "$TEMP_KEY" -N "" -q -C "azure-deploy-temp"
SSH_PUBLIC_KEY=$(cat "${TEMP_KEY}.pub")
rm -f "$TEMP_KEY" "${TEMP_KEY}.pub"
echo "SSH key generated (throwaway - access is via Tailscale)"

# Get Tailscale auth key from 1Password
TAILSCALE_AUTH_KEY=""
if [ -f "$OP_TOKEN_FILE" ] && command -v op &> /dev/null; then
    echo "Fetching Tailscale auth key from 1Password..."
    export OP_SERVICE_ACCOUNT_TOKEN="$(cat "$OP_TOKEN_FILE")"
    TAILSCALE_AUTH_KEY=$(op read "op://DEV_CLI/Tailscale/auth_key" 2>/dev/null || true)
    if [ -n "$TAILSCALE_AUTH_KEY" ]; then
        echo "Tailscale auth key found - VM will auto-connect to Tailscale"
    else
        echo "WARNING: Tailscale auth key not found in 1Password"
        echo "VM will not auto-connect to Tailscale. Run setup-tailscale.sh manually after deploy."
    fi
fi

# Create resource group if it doesn't exist
echo "Creating resource group ${RESOURCE_GROUP}..."
az group create --name "${RESOURCE_GROUP}" --location "${LOCATION}" --output none

# Deploy infrastructure
echo "Deploying infrastructure..."
DEPLOY_PARAMS=(
    --resource-group "${RESOURCE_GROUP}"
    --template-file "${INFRA_DIR}/main.bicep"
    --parameters
        location="swedencentral"
        namePrefix="dev-env"
        vmName="${VM_NAME}"
        vmSize="Standard_D2s_v6"
        osDiskSizeGB=64
        sshPublicKey="${SSH_PUBLIC_KEY}"
)
if [ -n "$TAILSCALE_AUTH_KEY" ]; then
    DEPLOY_PARAMS+=(tailscaleAuthKey="${TAILSCALE_AUTH_KEY}")
fi
az deployment group create "${DEPLOY_PARAMS[@]}" --output table

# Get public IP (still assigned, but SSH blocked by NSG)
echo ""
echo "=== Deployment Complete ==="
PUBLIC_IP=$(az vm show \
    --resource-group "${RESOURCE_GROUP}" \
    --name "${VM_NAME}" \
    --show-details \
    --query publicIps \
    --output tsv | tr -d '\r')

# Write config to .env file
cat > "${ENV_FILE}" << EOF
# Dev VM Configuration
# Auto-generated by deploy.sh on $(date)

VM_NAME=${VM_NAME}
RESOURCE_GROUP=${RESOURCE_GROUP}
SSH_USER=${SSH_USER}
TAILSCALE_HOSTNAME=dev-vm
EOF

echo "Config saved to ${ENV_FILE}"
echo ""
echo "Public IP: ${PUBLIC_IP} (SSH blocked by NSG - use Tailscale)"

if [ -n "$TAILSCALE_AUTH_KEY" ]; then
    echo ""
    echo "=== Waiting for Tailscale connection ==="
    echo "VM will auto-connect to Tailscale as 'dev-vm'..."
    echo "Waiting for cloud-init to complete and Tailscale to connect..."

    # Wait for Tailscale to come online (poll via Tailscale SSH)
    TAILSCALE_HOST="dev-vm"
    SSH_CMD="ssh -o StrictHostKeyChecking=accept-new -o ConnectTimeout=5 ${SSH_USER}@${TAILSCALE_HOST}"

    for i in {1..60}; do
        if $SSH_CMD "exit 0" 2>/dev/null; then
            echo ""
            echo "✓ Connected to VM via Tailscale!"
            break
        fi
        echo -n "."
        sleep 5
    done
    echo ""

    # Check cloud-init status
    if $SSH_CMD "exit 0" 2>/dev/null; then
        echo "=== Cloud-init Status ==="
        $SSH_CMD "cloud-init status --wait" 2>/dev/null || true

        INIT_COMPLETE=$($SSH_CMD "cat /var/log/cloud-init-complete.log 2>/dev/null" || true)
        if [ -n "$INIT_COMPLETE" ]; then
            echo "Cloud-init: SUCCESS"
        else
            echo "Cloud-init: WARNING - setup may not have completed"
            INIT_ERRORS=$($SSH_CMD "grep -i 'error\|failed\|fatal' /var/log/cloud-init-output.log 2>/dev/null | grep -v 'INFO\|DEBUG' | head -10" 2>/dev/null || true)
            if [ -n "$INIT_ERRORS" ]; then
                echo "Errors found:"
                echo "$INIT_ERRORS"
            fi
        fi

        # Sync secrets and setup dev_env
        if [ -f "${HOME}/.config/dev_env/op_token" ]; then
            echo ""
            echo "=== Syncing secrets to VM ==="
            scp -o StrictHostKeyChecking=accept-new "${HOME}/.config/dev_env/op_token" "${SSH_USER}@${TAILSCALE_HOST}:~/.config/dev_env/op_token" 2>/dev/null || {
                $SSH_CMD "mkdir -p ~/.config/dev_env"
                scp "${HOME}/.config/dev_env/op_token" "${SSH_USER}@${TAILSCALE_HOST}:~/.config/dev_env/op_token"
            }
            echo "✓ 1Password token synced"

            echo ""
            echo "=== Setting up dev_env on VM ==="
            $SSH_CMD bash -s <<'SETUP_EOF'
set -e
export OP_SERVICE_ACCOUNT_TOKEN="$(cat ~/.config/dev_env/op_token 2>/dev/null)"

# Set up git credential helper using gh CLI with PAT from 1Password
GITHUB_PAT=$(op read "op://DEV_CLI/GitHub/PAT" 2>/dev/null || true)
if [ -n "$GITHUB_PAT" ]; then
    echo "$GITHUB_PAT" | gh auth login --with-token
    gh auth setup-git
    echo "✓ GitHub CLI authenticated"
else
    echo "✗ GitHub PAT not found in 1Password - manual gh auth login required"
    exit 1
fi

# Clone dev_env repo if not exists
if [ ! -d ~/dev_env ]; then
    echo "Cloning dev_env repo..."
    git clone https://github.com/kirderfg/dev_env.git ~/dev_env
    echo "✓ dev_env cloned to ~/dev_env"
else
    echo "✓ dev_env already exists at ~/dev_env"
    cd ~/dev_env && git pull --ff-only || true
fi
SETUP_EOF
        fi
    else
        echo ""
        echo "WARNING: Could not connect via Tailscale after 5 minutes"
        echo "Check Tailscale admin console for device 'dev-vm'"
    fi

    echo ""
    echo "VM ready! Connect with: ssh ${SSH_USER}@dev-vm"
else
    echo ""
    echo "WARNING: No Tailscale auth key - VM has no network access!"
    echo "You'll need to:"
    echo "  1. Add SSH inbound rule to NSG manually"
    echo "  2. SSH in and run setup-tailscale.sh"
    echo "  3. Then remove the SSH rule"
fi

echo ""
echo "=== DevPod Usage ==="
echo "SSH to VM and run devpods with:"
echo "  ~/dev_env/scripts/dp.sh up https://github.com/user/repo"
echo "  ~/dev_env/scripts/dp.sh list"
