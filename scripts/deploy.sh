#!/bin/bash
set -e

# Configuration
RESOURCE_GROUP="rg-dev-env"
LOCATION="swedencentral"
VM_NAME="vm-dev"
SSH_USER="azureuser"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INFRA_DIR="${SCRIPT_DIR}/../infra"
ENV_FILE="${SCRIPT_DIR}/../.env"
OP_TOKEN_FILE="${HOME}/.config/dev_env/op_token"

echo "=== Azure Dev VM Deployment ==="

# Check if Azure CLI is installed
if ! command -v az &> /dev/null; then
    echo "Error: Azure CLI is not installed. Install it from https://docs.microsoft.com/en-us/cli/azure/install-azure-cli"
    exit 1
fi

# Check if logged in to Azure
if ! az account show &> /dev/null; then
    echo "Error: Not logged in to Azure. Run 'az login' first."
    exit 1
fi

# Check if VM already exists
echo "Checking for existing VM..."
VM_EXISTS=$(az vm show --resource-group "${RESOURCE_GROUP}" --name "${VM_NAME}" --query "id" -o tsv 2>/dev/null || true)

if [ -n "$VM_EXISTS" ]; then
    echo ""
    echo "WARNING: VM '${VM_NAME}' already exists in resource group '${RESOURCE_GROUP}'."
    echo "Cloud-init configuration cannot be changed on an existing VM."
    echo ""
    read -p "Delete resource group and start fresh? (y/n): " -n 1 -r REPLY </dev/tty
    echo ""

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo "Deleting resource group ${RESOURCE_GROUP}..."
        az group delete --name "${RESOURCE_GROUP}" --yes --no-wait

        echo "Waiting for deletion to complete..."
        while az group show --name "${RESOURCE_GROUP}" &>/dev/null; do
            echo -n "."
            sleep 5
        done
        echo ""
        echo "Resource group deleted."
    else
        echo "Aborting. To update NSG rules only, use Azure Portal or az CLI directly."
        exit 0
    fi
fi

# Generate throwaway SSH key (required by Azure, but we use Tailscale for access)
echo "Generating temporary SSH key for Azure..."
TEMP_KEY=$(mktemp -u)  # -u creates name only, doesn't create file
ssh-keygen -t ed25519 -f "$TEMP_KEY" -N "" -q -C "azure-deploy-temp"
SSH_PUBLIC_KEY=$(cat "${TEMP_KEY}.pub")
rm -f "$TEMP_KEY" "${TEMP_KEY}.pub"
echo "SSH key generated (throwaway - access is via Tailscale)"

# Get Tailscale keys from 1Password
TAILSCALE_AUTH_KEY=""
TAILSCALE_API_KEY=""
if [ -f "$OP_TOKEN_FILE" ] && command -v op &> /dev/null; then
    echo "Fetching Tailscale keys from 1Password..."
    export OP_SERVICE_ACCOUNT_TOKEN="$(cat "$OP_TOKEN_FILE")"
    TAILSCALE_AUTH_KEY=$(op read "op://DEV_CLI/Tailscale/auth_key" 2>/dev/null || true)
    TAILSCALE_API_KEY=$(op read "op://DEV_CLI/Tailscale/api_key" 2>/dev/null || true)
    if [ -n "$TAILSCALE_AUTH_KEY" ]; then
        echo "Tailscale auth key found - VM will auto-connect to Tailscale"
        if [ -n "$TAILSCALE_API_KEY" ]; then
            echo "Tailscale API key found - old 'dev-vm' device will be removed before registering"
        fi
    else
        echo "WARNING: Tailscale auth key not found in 1Password"
        echo "VM will not auto-connect to Tailscale. Run setup-tailscale.sh manually after deploy."
    fi
fi

# Create resource group if it doesn't exist
echo "Creating resource group ${RESOURCE_GROUP}..."
az group create --name "${RESOURCE_GROUP}" --location "${LOCATION}" --output none

# Deploy infrastructure
echo "Deploying infrastructure..."
DEPLOY_PARAMS=(
    --resource-group "${RESOURCE_GROUP}"
    --template-file "${INFRA_DIR}/main.bicep"
    --parameters
        location="swedencentral"
        namePrefix="dev-env"
        vmName="${VM_NAME}"
        vmSize="Standard_D8s_v6"
        osDiskSizeGB=64
        sshPublicKey="${SSH_PUBLIC_KEY}"
)
if [ -n "$TAILSCALE_AUTH_KEY" ]; then
    DEPLOY_PARAMS+=(tailscaleAuthKey="${TAILSCALE_AUTH_KEY}")
fi
if [ -n "$TAILSCALE_API_KEY" ]; then
    DEPLOY_PARAMS+=(tailscaleApiKey="${TAILSCALE_API_KEY}")
fi
az deployment group create "${DEPLOY_PARAMS[@]}" --output table

# Get public IP (still assigned, but SSH blocked by NSG)
echo ""
echo "=== Deployment Complete ==="
PUBLIC_IP=$(az vm show \
    --resource-group "${RESOURCE_GROUP}" \
    --name "${VM_NAME}" \
    --show-details \
    --query publicIps \
    --output tsv | tr -d '\r')

# Write config to .env file
cat > "${ENV_FILE}" << EOF
# Dev VM Configuration
# Auto-generated by deploy.sh on $(date)

VM_NAME=${VM_NAME}
RESOURCE_GROUP=${RESOURCE_GROUP}
SSH_USER=${SSH_USER}
TAILSCALE_HOSTNAME=dev-vm
EOF

echo "Config saved to ${ENV_FILE}"
echo ""
echo "Public IP: ${PUBLIC_IP} (SSH blocked by NSG - use Tailscale)"

if [ -n "$TAILSCALE_AUTH_KEY" ]; then
    echo ""
    echo "=== Waiting for cloud-init to complete ==="

    # Wait for cloud-init using az vm run-command (works from Cloud Shell without Tailscale)
    echo "Checking cloud-init status..."
    for i in {1..60}; do
        CLOUD_INIT_STATUS=$(az vm run-command invoke \
            --resource-group "${RESOURCE_GROUP}" \
            --name "${VM_NAME}" \
            --command-id RunShellScript \
            --scripts "cloud-init status 2>/dev/null | grep -o 'done\|running\|error' || echo 'waiting'" \
            --query "value[0].message" -o tsv 2>/dev/null | grep -o 'done\|running\|error\|waiting' | head -1)

        if [ "$CLOUD_INIT_STATUS" = "done" ]; then
            echo ""
            echo "✓ Cloud-init completed"
            break
        elif [ "$CLOUD_INIT_STATUS" = "error" ]; then
            echo ""
            echo "✗ Cloud-init failed - check VM logs"
            break
        fi
        echo -n "."
        sleep 10
    done
    echo ""

    # Sync secrets and setup dev_env using az vm run-command
    # This works from Azure Cloud Shell which doesn't have Tailscale
    if [ -f "${HOME}/.config/dev_env/op_token" ]; then
        echo ""
        echo "=== Syncing secrets to VM ==="
        OP_TOKEN=$(cat "${HOME}/.config/dev_env/op_token")

        # Use az vm run-command to write token and run shell-bootstrap
        az vm run-command invoke \
            --resource-group "${RESOURCE_GROUP}" \
            --name "${VM_NAME}" \
            --command-id RunShellScript \
            --scripts "
mkdir -p /home/${SSH_USER}/.config/dev_env
chmod 700 /home/${SSH_USER}/.config/dev_env
cat > /home/${SSH_USER}/.config/dev_env/op_token << 'TOKENEOF'
${OP_TOKEN}
TOKENEOF
chmod 600 /home/${SSH_USER}/.config/dev_env/op_token
chown -R ${SSH_USER}:${SSH_USER} /home/${SSH_USER}/.config/dev_env
echo 'Token written successfully'
" --query "value[0].message" -o tsv 2>/dev/null | tail -5

        echo "✓ 1Password token synced"

        echo ""
        echo "=== Setting up dev_env on VM ==="
        az vm run-command invoke \
            --resource-group "${RESOURCE_GROUP}" \
            --name "${VM_NAME}" \
            --command-id RunShellScript \
            --scripts '
set -e
export HOME=/home/'"${SSH_USER}"'
cd $HOME
export OP_SERVICE_ACCOUNT_TOKEN="$(cat $HOME/.config/dev_env/op_token 2>/dev/null)"

# Clone dev_env repo if not exists
if [ ! -d $HOME/dev_env ]; then
    echo "Cloning dev_env repo..."
    GITHUB_PAT=$(op read "op://DEV_CLI/GitHub/PAT" 2>/dev/null || true)
    if [ -n "$GITHUB_PAT" ]; then
        su - '"${SSH_USER}"' -c "git clone https://${GITHUB_PAT}@github.com/kirderfg/dev_env.git $HOME/dev_env"
        echo "✓ dev_env cloned"
    else
        echo "✗ GitHub PAT not found"
        exit 1
    fi
else
    echo "✓ dev_env already exists"
    su - '"${SSH_USER}"' -c "cd $HOME/dev_env && git pull --ff-only" || true
fi

# Re-run shell-bootstrap with token to configure gh/atuin/git/pet
echo ""
echo "=== Running shell-bootstrap with 1Password token ==="
su - '"${SSH_USER}"' -c "
export OP_SERVICE_ACCOUNT_TOKEN=\"\$(cat ~/.config/dev_env/op_token)\"
curl -fsSL https://raw.githubusercontent.com/kirderfg/shell-bootstrap/main/install.sh -o /tmp/shell-bootstrap-install.sh
SHELL_BOOTSTRAP_NONINTERACTIVE=1 bash /tmp/shell-bootstrap-install.sh
rm -f /tmp/shell-bootstrap-install.sh
"
echo "✓ Shell environment configured"
' --query "value[0].message" -o tsv 2>/dev/null | tail -20
    fi

    echo ""
    echo "VM ready! Connect with: ssh ${SSH_USER}@dev-vm"
else
    echo ""
    echo "WARNING: No Tailscale auth key - VM has no network access!"
    echo "You'll need to:"
    echo "  1. Add SSH inbound rule to NSG manually"
    echo "  2. SSH in and run setup-tailscale.sh"
    echo "  3. Then remove the SSH rule"
fi

echo ""
echo "=== DevPod Usage ==="
echo "SSH to VM and run devpods with:"
echo "  ~/dev_env/scripts/dp.sh up https://github.com/user/repo"
echo "  ~/dev_env/scripts/dp.sh list"
